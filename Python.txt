                    Python Concepts
                    ===============
Table of Contents
---
- Overview
- Loops: If, While, For etc
- Data Structures: Lists, Tuples, Sets, Dictionary
- Functions: Decorators, Generators
- *args and **kwargs
- OOP
    * Instance variables vs Class variables
- Map, Reduce, Filter
- Lambda Functions


Overview
========
- Dynamically-typed, strong-reference language

Loops: If, While, For ...
=====================
Loops
----
- Iterables are strings, lists, set, tuples and more

my_string = "Hello"
for c in my_string:
    print(c)


Input()
----
- Accepts input from CLI

user_input = input("Please answer yes/no (y/n)?")   # Python 3.5 only
if user_input == 'n':
    # do something

If statements
----





Data Structures
===============
Lists, Tuples & Sets
----
- Tuples are immutable
- Sets are unique and unordered

Ex:
    grades = [77, 80, 99, 100]  # Lists are ordered
    tups   = (77, 80, 99, 100)  # Typles are immutable
    sets   = {77, 80, 99, 100, 100} # Sets are unordered and unique. There'll
                                    # be only ONE 100
    print(len(grades))          # len() function calculates length of list
    print(sum(grades))          # sum() adds up elements of list

Set operations
----
    tups = (77, 80, 99)
    tups = tups + (100,)    # Note the , after 100. That's important
    tups2 = (15)            # NOT a tuple. It's just a number with braces
    tups2 = (15,)           # This is a tuple.
    tups2 = 15,             # This is a tuple.

    grades[0] = 50  # assignment. Allowed
    tups[0] = 50    # Not Allowed. Tuples are immutable
    sets[0] = 50    # Sets are unordered. We don't know which element is being
                    # replaced


- Add element to a set
    sets.add(60)
- Add element to a list
    grades.append(60)

- Union, Intersection, Difference of two sets
    set_one = {1,2,3,4,5}
    set_two = {1,3,5,7,9}
    print(set_one.union(set_two))           # output: 1,2,3,4,5,7,9
    print(set_one.intersection(set_two))    # output: 1,3,5
    print(set_one.difference())


List Comprehension
----
my_list = [x for x in range(5)]     # way of building a list
my_list = range(5)                  # also does the same thing
my_list = [x*3 for x in range(5)]   # [0, 3, 6, 9, 12]

print([n for n in range(10) if n%2==0])


Dictionary
----
- key:value pairs. Both keys and values can be anything. Very similar to hash
- Value can be another list, set, tuple or even dictionary

lottery_player = {
    'name' : 'Rolf',
    'numbers' : (13, 45, 66, 23, 22)    # value is a tuple
}

universities = {
    {
        'name' : 'Oxford',
        'location' : 'UK'
    },

    {
        'name' : 'MIT',
        'location' : 'US'
    }
}

- Accessing a key in Dictionary is using [] braces
    lottery_player['numbers']


Functions: Decorators, Generators
=================================
- Functions are first class objects in Python. It can be passed as args to
  other functions and returned from a function

Positional Arguments: Arguments to a function...that's it.
Keyword Arguments: A key=value pair in arguments. Order is not important


*args and **kwargs
---
- *args means variable function arguments, passed as List
- **kwargs means variable keyword arguments, passed as Set. Note that keyword
  arguments MUST follow positional arguments

Mutable Objects: Set, List, Dictionary
Immutable Objects: String, Integer, Float, Tuple, bool



Decorators
----------
# the function outer is the decorator
def outer(some_func):
    def inner():
		# do some work before the function
        ret = some_func()
        # do some work after the function
        return ret + 1
    return inner # we alway return inner function

def re_one():
    return 1

# First method to use a decorator
outer(re_one)()
# outer is the decorator for re_one. Any calls to re_one won't get the
# original re_one, instead will get the decorated version.

# Second method to use a decorator
@outer
def re_two():
    return 1

re_two()




Generators:
-----------
- Generators: They are Iterators that can iterate only once. Usually
  implemented as functions that 'yeild' and not 'return'

- Used when calculating large sets of data where intermediate results is not
  required to be saved for long.

Ex: Fibonacci numbers

# generator version
def fibon(n):
    a = b = 1
    for i in range(n):
        yield a
        a, b = b, a + b

This is used as follows:

for x in fibon(10000):
    print(x)


@classmethod and @staticmethod
----
- A method that doesn't change for various objects of class can be declared
  with @classmethod. This makes it like a 'global' method for the class.

class Student:
    def __init__(self):
        self.name = "Greg"
        self.school = "MIT"

    @classmethod
    def get_school(cls):
        print("I study at MIT")

    @staticmethod
    def get_student():
        print("I'm a student")

- These methods are called using class name


OOP
---
- Instance variables are created using __ (double underscore) before the
  variable
- Even private methods are created this way
- How to access private methods?
    * By other methods in same class
    * Using round about way: instance._classname__privatemethod()
- Old style class vs New style class
- In Python there are no true private or protected variables
- Python Classes are similar to C++ Classes. Python has most of the OOPs concepts
- There is Garbage Collection in Python and hence, no need for explicit destroy
  of objects
- By default, class members are public


Class
-----
class Name(object): # usual upper/lower case convention
- Ideal to have __init__ method with attributes
- 'self' is first attribute in all methods, including __init__
- Class variable is created outside of any class method. One variable is
  shared across all instances.

Class Variable vs Instance Variables
---
- Instance variables are defined within a method and accessed using 'self'
  attribute
- Class variables are defined outside all methods in the class and don't need
  'self' keyword to access it

- Example:

class Employee(object):
    empCount = 0 #Class variable. No self. prefix
    className = 'Employee' #Class variable. No self. prefix
    def __init__(self, name, salary):
        self.name = name
        self.salary = salary
        Employee.empCount +=1


- Classes have built-in attributes
    __dict__    Dictionary containing class's namespace
    __doc__     Class documentation string or None if undefined
    __name__    Class name
    __module__  Module name in which the class is defined. This attribute is
                __main__ in interactive mode
    __base__    Possibly empty tuple containing base classes, in the order of
                their occurrence in base class list
    __del__
    __str__     In Python 3, it's recommended to have __repr__ instead of
                __str__

- Utility functions
    hasattr()
    getattr()
    setattr()

- hasattr() can be used to check if an instance has a specific attribute
    $ hasattr(obj1, 'name')    # Returns true if 'name' attribute exists

Deleting a Class Object
----
- Two ways to do it. But recommended way is 3rd one (Python's GC)
    1) del obj1
    2) obj1 = None



Inheritance
---
# An example of an inherited class
class Animal(object):
    def say_something(self):
        return "I'm an animal!"

'''
Here Cat and Dog are child classes that are inheriting from Animal.
The child class, say_something method overrides the behavior
of the say_something of the parent class. This is called method overriding.
'''

class Cat(Animal):
    def say_something(self):
        return "Meow"

class Dog(Animal):
    def say_something(self):
        return "Bow-wow"

a = Animal()
print a.say_something()
d = Dog()
print d.say_something()	# method overriding
c = Cat()
print c.say_something()


- Accessing parent class methods is done using:
    super(child_class_name, self).some_parent_method()


# Method overloading in the same class.
# Only the last method definition is used.
class Animal(object):
    name = 'Animal'
    def eat(self):
        print "Animal eating"

    def drink(self,name):
        print 'Animal %s drinking'%(name)

    def drink(self, name = 'Dog'):
        print 'Latest method - Animal %s drinking: '%(name)

a = Animal()
a.drink()
b = Animal()
b.drink('Cow')

Latest method - Animal Dog drinking:
Latest method - Animal Cow drinking:


# Multiple inheritance.  A child can have multiple parents.
class Organism(object):
    name = 'Organism'
    def eat(self):
        print 'Organism eating'
    def drink(self):
        print 'Organism drinking'

class Animal(object):
    name = 'Animal'
    def eat(self):
        print "Animal eating"

class Dog(Organism,Animal):
    #name = 'Dog'
    def eat(self):
        print "Dog eating"

d = Dog()
d.eat()
print d.name
d.drink()


Old Style Class vs New Style Class
---
In the old style class, the class will not inherit from Python object class
and will have access to fewer attributes and methods.

class ClassA:
    def method1(self):
        pass


In new style class, the class will inherit from Python object class and will
have access to more attributes and methods.

class ClassA(object):
    def method1(self):
        pass


Operator Overloading
--------------------
- Methods that needs overloaded for various operations
	+		__add__
	- 		__sub__
	==		__eq__  This method is NOT used to overload !=
	!=		__ne__
	<		__lt__
	>		__gt__
	<=		__le__
	>=		__ge__
			__cmp__  This can be used to overload all 6 of above operators



Python Modules
---
csv     For reading and writing in to CSV files
xlrd    For reading from excel files
xlwt    For writing in to excel files
openpyxl    Another module to read/write to excel file
sqlite3     Reading/Writing in to SQLite3 Database
os      OS related dependent functionalities
glob    Run regex on all pathnames/files to match files and directories

Different ways of importing module
---
[1]
# Import all functions in a given module.
# We have to refer to the module name when
# calling the function
import math
print math.sin(math.pi/4)

[2]
# Import all functions in a given module.
# We do not need to refer to the module name when
# calling the function
from math import *
print sin(pi/4)

[3]
# Give a shortcut name to the module.
# Especially true for modules with long names such as matplotlib
import math as ma
print ma.sin(ma.pi/4)

[4]
# Only import the necessary functions from a module
# This is memory efficient
from math import sin,pi
print sin(pi/4)







Strings & Texts
----

Slicing
----
message = "Hello World"

- All 3 "arguments" below are optional
message[start_idx:(end_idx+1):step=1]

message[0:5]    # beginning to 4th char inclusive
message[:5]     # beginning to 4th char inclusive
message[3:]     # 3rd char to end of the string

message[-1]     # last char, same as message[len-1]

message[8:3:-1] # prints in reverse order
message[::-1]   # prints entire list in reverse, but reversed() method is
                # preferred

message.lower()
message.upper()
message.count(str)  # count # of times str occurs in message
message.find(str)   # starting index of str if present or -1 if not present
message.replace(orig_str, new_str)


Concatenation
----
- Concatenting strings is just addition, but there are other approaches
    greeting = 'Hello'
    name = 'Michael'
    message = greeting + ', ' + name

- Note that dir(variable) function gives all methods and variables available
  on that variable "type". There's no explanation on each method.

- Do help(class of object) and you'll get lot more info.
    Ex: help(str) gives lot of info on strings
        help(str.lower) gives info on lower method of strings





- f-strings: Python 3.6 and above
- Very cool feature

    ten = 10
    f"Hello world! There are {ten} people in world"

- Another formatting using .format() syntax

    hilarious = False
    joke_evaluation = "Isn't that joke so funny?! {}"
    print(joke_evaluation.format(hilarious))

- *args and **kwargs
    *args means variable function arguments
    **kwargs means variable key-value arguments

- Generators
    * Iterable
    * Iterator
    * Iteration

- Iterable: Any Python object that can give us an Iterator
- Python object should have __iter__ or __getitem__ method defined
  which returns an Iterator


- Iterator: Any Python object that has next method (Python2) or __next__
  method defined.

- Iteration: Process of iterating


Map, Filter and Reduce and Lambda Functions
======================
- Functional approach to programming

Lambda Functions: Anonymous functions, used as throw away functions and only
needed once
- Syntax:
    lambda inputs : output
- Example:
    lambda x : x%2 != 0


Map: Applies a function to all items in an input list and returns a list
    map(function_to_apply, list_of_inputs)

Ex:

items = [1, 2, 3, 4, 5]
squared = []
for i in items:
    squared.append(i**2)

Above task can be simplified using Map as follows:

items = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x**2, items))

It's possible to have list of functions as input on which to run Map()
function.

def multiply(x):
    return (x*x)
def add(x):
    return (x+x)

funcs = [multiply, add]
for i in range(5):
    value = list(map(lambda x: x(i), funcs))
    print(value)

# Output:
# [0, 0]
# [1, 2]
# [4, 4]
# [9, 6]
# [16, 8]



Filter: Create a list of elements for which a function returns True

number_list = range(-5, 5)
less_than_zero = list(filter(lambda x: x < 0, number_list))
print(less_than_zero)

# Output: [-5, -4, -3, -2, -1]



Reduce: Applies a rolling computation to sequential pair of elements of list.
For example, product of elements of a list

product = 1
list = [1, 2, 3, 4]
for num in list:
    product = product * num

# product = 24


With reduce:

from functools import reduce
product = reduce((lambda x, y: x * y), [1, 2, 3, 4])


TIPS
====
- sort() can be applied on lists (and ...??). It sorts the list in place.
  sorted() requires new list

    mylist.sort(reverse=True)   # sorts in reverse order

- For list of lists, sort() function sorts on first element in the list

- Understand the difference between append()'ing and extend()'ing a list to
  another list

- Deep copy of a list can be done by slicing [:]

    mylist = [5, 9, 3]
    dcopy = mylist[:]

- dir(class_name) gives all methods in that class



@@@@@@@@@@@@@@@@@@      CODING        COMPETITIONS      @@@@@@@@@@@@@@@@@@@@@@
Few APIs/library calls that's useful

chr(...)
    chr(i) -> character
    Return a string of one character with ordinal i; 0 <= i < 256.

ord(...)
    ord(c) -> integer
    Return the integer ordinal of a one-character string.

sort()
    - method that can only be called on a list
    - Does not work on any enumerable, unlike sorted()
    - Does not return a list. It just sorts original list
    - Method found in older code

sorted(...)
    sorted(iterable, cmp=None, key=None, reverse=False) --> new sorted list
    - NOTE that this returns new list and does NOT modify existing list
    - 'key' is a function. It runs on each input and returns a numeric value.
      That value is used in sorting.

  strs = ['ccc', 'aaaa', 'd', 'bb']
  print sorted(strs, key=len)  ## ['d', 'bb', 'ccc', 'aaaa']

    - Read more at this link:
https://developers.google.com/edu/python/sorting




@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


Reference:
[1] https://learnpythonthehardway.org/python3/
[2] http://book.pythontips.com/en/latest/
[3] Safari Books Online: REST APIs with Flask and Python (video)
[4] UCSC Extension Class: Python for Programmers

Decorators
[5] http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/
[6] http://thecodeship.com/patterns/guide-to-python-function-decorators/

OOPS
[7] http://www.tutorialspoint.com/python/python_classes_objects.htm
[8] http://www.jeffknupp.com/blog/2014/06/18/improve-your-python-python-classes-and-object-oriented-programming/

Private Methods
[9] http://stackoverflow.com/questions/70528/why-are-pythons-private- methods-not-actually-private
[10] http://effbot.org/pyfaq/tutor-how-do-i-make-public-and-private-attributes- and-methods-in-my-classes.htm

Multiple Inheritance
[11] http://stackoverflow.com/questions/3277367/how-does-pythons-super-work-with-multiple-inheritance
[12] http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem

Operator Overloading
[13] https://docs.python.org/2/library/operator.html
[14] http://thepythonguru.com/python-operator-overloading/
