                        NOTES FROM [1]
                        =============
        STACK SMASHING/OVERFLOW

        HEAP OVERFLOW
        =============
Example:
typedef struct _vulnerable_struct {
        char buff[MAX_LEN];
        int (*cmp) (char *, char *);
} vulnerable;

int foo (vulnerable *s, char *one, char *two)
{
        strcpy (s->buff, one); // copy one in to buff
        strcpy (s->buff, two); // copy two in to buff

        return s->cmp (s->buff, "file://foobar");
}
// works only if strlen(one) + strlen(two) < MAX_LEN.
// Otherwise, we overwrite s->cmp function pointer.

- In C++, vtable represents objects and its data/methods. With Heap
  Overflow attacks, vtable can be corrupted and object methods can be
  overwritten.

- Variants of Heap Overflow include:
        - Overflow in to C++ vtable (as mentioned above).
        - Overflow in to adjacent objects.
        - Overflow in to heap metadata.
                - Hidden header just before the pointer returned by
                  malloc. Flow in to that header to corrupt heap itself.



        INTEGER OVERFLOW
        ================
- Wrapping around of integers.

void vulnerable()
{
        char *response;
        int nresp = packet_get_int();

        if (nresp > 0) {
                response = malloc(nresp * sizeof(char *));
                for (i=0; i<nresp; i++)
                        response[i] = packet_get_string(NULL);
        }
}

- If nresp is very large and sizeof(char *) is 4 (32-bit) then their
  product will wrap and become zero (??).
- Subsequent writes to that buffer are overflowing it.

- So far, code was corrupted. But its possible to corrupt data.

        READ OVERFLOW
        =============

int main()
{
        char buff[100], *p;
        int i, len;

        while(1) {
                // read integer, which is len.
                p = fgets(buf, sizeof(buf), stdin);
                if (p==NULL)
                        return 0;
                len = atoi(p);

                // read message
                p = fgets(buf, sizeof(buf), stdin);
                if (p==NULL)
                        return 0;

                // print message. If len is more than message length, its
                // a problem.
                for (i=0; i<len; i++) {
                        if (!iscntrl(buf[i]))
                                putchar (buf[i]);
                        else
                                putchar ('.');
                }

                printf("\n");
        }
}

- Heartbleed bug is an exampleof Read Overflow bug.

        STALE MEMORY BUGS
        =================
- Dangling pointer bug. An attacker can arrange for the freed memory to be
  reallocated and under his control.

struct foo {
        int (*cmp) (char *, char *);
};

struct foo *p = malloc(...);
...
free (p);
...
q = malloc (...) //reuses memory
...
*q = 0xdeadbeef; // attacker controlled memory
...
p->cmp ("hello", "hello"); // dangling pntr. Attacker controlled memory.


        FORMAT STRING ATTACK
        ====================

void safe()
{
        char buf[80];
        if (fgets (buf, sizeof(buf), stdin) == NULL)
                return;
        printf ("%s", buf);
}

void vulnerable()
{
        char buf[80];
        if (fgets (buf, sizeof(buf), stdin) == NULL)
                return;
        printf (buf); // (1)
}

(1) In this printf, contents of 'buf' is interpreted. So, if it contains
format string specifiers, they are interpreted. How can this be used to
attack?

How is below code represented on Stack?

int i = 10;
printf ("%d %p\n", i, &i);

        ------+----------+----------+------+---+----+----------------
          ... | old %ebp | ret addr | &fmt | i | &i | caller frame
        ------+----------+----------+------+---+----+----------------

- Note that stack grows Right to Left.
- When printf() sees %d, it looks for 'i', and %p looks for '&i'.
- Look at following code:
        printf("%d %x");

        ------+----------+----------+------+-------------------------
          ... | old %ebp | ret addr | &fmt |     caller frame
        ------+----------+----------+------+-------------------------

- In above stack, printf() reads and interprets contents of caller frame.

- Some examples of Format String Vulnerabilities.

printf("100% dave");
        * Prints stack entry 4 bytes above saved ret addr (%eip). That's
        * because, printf ignores space between % and next letter ('d').
printf("%s");
        * Prints bytes pointed to by that stack entry till it encounters
        * NULL.
printf("%d %d %d ...");
        * Prints a series of stack entries as integers.
printf("%08x %08x %08x ...")
        * Same as above but formatted in hex.
printf("100% no way!");
        * WRITES the number 3 to address pointed to by stack entry because
        * %n is used to write progress that printf() made in printing to
        * output stream. In this case, printf() would have printed 3
        * characters (100) and hence, it prints 3 on stack.

DEFENSE AGAINST OVERFLOW ATTACKS
=====
- Memory safety and type safety. Coding in a way to ensure application is
  immune to memory attacks.
- Automatic defenses: (a) Stack Canaries (b) ASLR: Automatic Space Layout
  Randomization. OS/Compiler does above things for us.
- Return-Oriented Prog (ROP) attack overcomes above two techniques.
  Control Flow Integrity (CFI) can defeat ROP. But it is in its infancy.

MEMORY SAFETY
=============















Format String Bugs
==================
- printf() accepts %x format specifier without an argument. It prints contents
  of stack
    printf("%x");   /* works, with a warning */

    // printf accepts without argument and print whatever is available next on
    // the stack.

    void main(int argc, char *argv[])
    {
        char buf[4];
        strcpy(buf, argv[1]);
        printf(buf);
    }

    $ ./a.out %x.%x.%x
    *** stack smashing detected ***: ./a.out terminated
    b650caac.78252e.252e7825.4006b0Aborted


- %n writes number of chars printed so far, to mem location pointed to by a
  param

- Stack defenses don't help
    * Canary value
    * ASLR and NX (non-executable stack) makes it hard, but not impossible
    * Static code analysis tools generally find this
    * GCC warns, but no defense


















References:
[1] Coursera: Software Security from University of Maryland
[2] CNIT 127 Exploit Development - City College of San Francisco


@@@@@@@@@@@@@@@@@    ATTACK     NAMES    @@@@@@@@@@@@@@@@

TCP Attacks
---
TCP Reset: https://en.wikipedia.org/wiki/TCP_reset_attack
TCP Sequence Prediction:
https://en.wikipedia.org/wiki/TCP_sequence_prediction_attack
MITM: https://en.wikipedia.org/wiki/Man-in-the-middle_attack
SYN Flood: https://en.wikipedia.org/wiki/SYN_flood
Sockstress: https://en.wikipedia.org/wiki/Sockstress
PUSH & ACK Floods: https://en.wikipedia.org/wiki/PUSH_and_ACK_floods
TCP Veto:

UDP Attacks
---
UDP Flood: https://en.wikipedia.org/wiki/UDP_flood_attack


DNS Attacks
---
DNS Rebinding: https://en.wikipedia.org/wiki/DNS_rebinding
DNS Hijacking: https://en.wikipedia.org/wiki/DNS_hijacking
DNS Spoofing: https://en.wikipedia.org/wiki/DNS_spoofing
DNS Cache Poisoning: https://en.wikipedia.org/wiki/DNS_cache_poisoning

